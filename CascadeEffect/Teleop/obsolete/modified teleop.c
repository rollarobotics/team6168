#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo) */
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     frontLeft,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     frontRight,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     backLeft,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     backRight,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     spinner,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     lift,          tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    tubeClamp,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    tubeDrop,             tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_3,    rampDrop,             tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*Programmers: Connor       file: DriveTrainV1.c     Region: teleop    Year: cascade effect
creation date: 10-30-14                                    update: 12-12-14
summary: First version of our drivetrain software
*/


//global variables and includes:
#include "JoystickDriver.c"



/*purpose: Our drive train. Pass in the x and y coordinates from main,
we determine our power P based off of the hypotenuse of the triangle
formed by x and y on the controller's grid, then depending on which
quadrant we're in we assign 2 motors to have a straight power passed
to them, and 2 of them have their power multiplied times the equation
(x^2-y^2)/(x^2 + y^2), which is the reduced form of cos(angle), where
angle is the angle formed by the triangle. The end result is that
two of the motors have their power varied by their degree, going from
power * -1, to 0, to power * 1. This reduction in magnitude of power
allows for true omnidirectional movement. Then we take our current
heading as given by a gyro, and use that to calculate what direction
the robot needs to move in, to allow us to have the robot move
according to our perspective instead of its. So, find power and quadrant
and then apply the formulas based on quadrant. Cardinal direction is case 5
of the switch case, as it requires different formulas.
input: x and y coordinate
output: robot moves
*/
void driveTrain(int X1, int Y1, int Y2)
{
	const int deadZone = 10;
  //	nxtDisplayTextLine(1, "x: %d", x);
	//	nxtDisplayTextLine(2, "y: %d", y);
	if(abs(X1) < deadZone)  //Setting the deadzone
	 {
		X1 = 0;
	 }
	if (abs(Y1 & Y2) < deadZone)
	 {
		Y1 = 0;
		Y2 = 0;
	 }
	//drive motors going left to right
	if(abs(joystick.joy1_y1) > deadZone)
   {
  	Y1 = joystick.joy1_y1;
   }
	else
	 {
	  Y1 = 0;
	 }
	 //drive motors going forward to backward
	if(abs(joystick.joy1_x1) > deadZone)
	 {
	   X1 = joystick.joy1_x1;
	 }
	else
	 {
	   X1 = 0;
	 }
	 //z axis rotation
	 if(abs(joystick.joy1_y2) > deadZone)
	  {
	  	Y2 = joystick.joy1_y2;
	  }
	 else if(abs(joystick.joy1_x2) > deadZone)
	  {
	  	Y2 = joystick.joy1_x2;
	  }
	 else
	   Y2 = 0;

motor[frontRight] = Y1 - Y2 - X1;
motor[frontLeft] = Y1 + Y2 + X1;
motor[backRight] = Y1 - Y2 + X1;
motor[backLeft] = Y1 + Y2 - X1;
}


void spin(bool butt1, bool butt2)
{
	if(butt1 == true)
	{
		motor[spinner] = 100;
	}

	else if(butt2 == true)
	{
		motor[spinner] = -100;
	}
}

task main()
{
int X1;
int Y1;
int Y2;
const int deadZone = 10;

  while(true)
	{
		eraseDisplay();
		getJoystickSettings(joystick);
		if((abs(joystick.joy1_y1) > deadZone) || (abs(joystick.joy1_x1) > deadZone) || abs(joystick.joy1_x2) > deadZone)
		{
			nxtDisplayTextLine(6, "inside");
			driveTrain(X1,Y1,Y2);
		}
		else
			driveTrain(0,0,0);

		if(joy1Btn(5) == true || joy1Btn(6) == true)
		{
			spin(joy1Btn(5), joy1Btn(6));
		}
		else
			motor[spinner] = 0;


		if(joy2Btn(4))
		{
			motor[lift] = 78;
		}
		else if(joy2Btn(2))
		{
			motor[lift] = -78;
		}
		else
		{
			motor[lift] = 0;
		}



		if(joy2Btn(7))
		{
			servo[tubeClamp] = 200;
		}
		else{
			servo[tubeClamp] = 0;
		}

		if(joy1Btn(10))
			servo[rampDrop] = 255;

		if(joy2Btn(5))
			servo[tubeDrop] = 255;
		else if(joy2Btn(6))
			servo[tubeDrop] = 0;
		else
			servo[tubeDrop] = 126;


	}
}
